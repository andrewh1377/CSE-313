;Class:CSE 313 Machine Organization Lab
;Quarter: Fall 2016
;Name(s): Andrew Hedy, Steven Tang
;Lab 8: Random Number Generator
;Description: Generate random numbers using a Linear Congruential Random Number Generator (LCRNG).
	     ;Using formula A (X MOD Q) - R (X / Q) with input A = 7, M = 32767, and X = 10. 
	     ;This loops through creating 20 random numbers, inputs each number into a stack then
	     ;pops and outputs the numbers for display. 



.ORIG x3000		
	
;-------------------------JUMP TO SUBROUTINES-------------------------	

	LEA R0, Outputs
	PUTS
	LD R0, XOUTPUT
	OUT

LOOP
	
	;A (X MOD Q) - R (X / Q)
	LD R1, M		;USER INPUTED M
	LD R2, A		;USER INPUT A


	JSR DIV			;Q = (M/A)
	LDI R3, DIVIDED
	ST R3, Q		;R3 IS THE OUPUT FROM X DIVIDED BY Y

	JSR MOD			;R = (M%A)
	LDI R3, MODULUS		;SAVING OUTPUT
	ST R3, R

	LD R1, X
	LD R2, Q		;CALLING OUR Q WHERE IT WAS M/A
	JSR MOD			;(X%Q)
	
	LD R1, A
	LDI R2, MODULUS
	JSR MULT		;(A*(X%Q))
	LDI R3, XY		;SAVING OUTPUT
	
	LD R1, X
	LD R2, Q
	JSR DIV			;(X/Q)
	
	LD R1, R
	LDI R2, DIVIDED
	JSR MULT 		;(R*(X/Q))
	LDI R4, XY		;SAVING OUTPUT

	NOT R4, R4		;NEGATING R4(R*(X/Q)) TO SUBTRACT FROM R3(A*(X%Q))
	ADD R4, R4, #1		;ADD 1 FOR 2'S COMPLEMENT
	
	ADD R3, R3, R4		;(A*(X%Q)-R*(X/Q))
	ST R3, X		;STORE RESULT OF R3 INTO LABEL 'X'
	LD R5, X		;LOAD VALUE OF 'X' INTO R5
	BRn OUTPUTNEG		;IF VALUE IS NEGATIVE BRANCH
	JSR OUTPUT

OUTPUTNEG	LDI R2, M
		ADD R1, R1, R2 
		JSR OUTPUT
		
		LD R1, RANDGEN
		ADD R1, R1, #-1
		BRz LOOPSTOP
		ST R1, RANDGEN
		BR LOOP

LOOPSTOP

HALT

M 	.FILL #32767		;
A 	.FILL x0007		;
X 	.FILL x0000		;
Q 	.FILL x0000
R 	.FILL x0000
XY 	.FILL x3101		;SAVE X*Y INTO M[x3100]
DIVIDED	.FILL x3102		;SAVE X/Y INTO M[x3101]
MODULUS	.FILL x3103		;SAVE X%Y INTO M[x3102]
RANDGEN .FILL x000A		;SEED THAT DECREMENTS EACH LOOP
Outputs	.STRINGZ "Generated Numbers: "
XOUTPUT	.BLKW 10 x3400


;-----------------------MULTIPLY--------------------------------
	;R1 = X, R2 = Y, R3 = COUNTER(END VALUE), R5 = SIGN FLAG


MULT	
		STI R1, SAVER1		;SAVING REGISTERS
		STI R2, SAVER2		;
		STI R3, SAVER3		;
		STI R4, SAVER4		;
		STI R7, SAVER7		;

		AND R4, R4, #0		;CHECKING R4(SIGN FLAG)
		ADD R1, R1, #0		;CHECKING R1(X)
		BRn XNEG		;IF X IS NEGATIVE BRANCH	
		BR #3		
		 
XNEG		NOT R1, R1		;NEGATE R1(X)
		ADD R1, R1, #1		;ADD 1 FOR 2'S COMPLEMENT
		NOT R4, R4		;CHANGE SIGN FLAG
		ADD R2, R2, #0		;CHECKING R2(Y)
		BRn YNEG		;IF Y IS NEGATIVE BRANCH
		BR #3			

YNEG		NOT R2, R2		;NEGATE R2(Y)
		ADD R2, R2, #1		;ADD 1 FOR 2'S COMPLEMENT
		NOT R4, R4		;CHANGE SIGN FLAG
		AND R3, R3, #0		;CLEARING R3

MULTIPLY	ADD R3, R3, R1		;ADD X INTO R3
		ADD R2, R2, #-1		;R2 DECREMENTS UNTIL ZERO
		BRnp MULTIPLY		;LOOP THROUGH AGAIN IF NOT ZERO		
		ADD R4, R4, #0		;CHECKING SIGN FLAG
		BRn SIGN		;IF SIGN FLAG IS NEGATIVE CHANGE R3(RESULT)
		BR #2			;IF NOT NEGATIVE EXIT

SIGN		NOT R3, R3		;NEGATING R3(RESULT)
		ADD R3, R3, #1		;ADDING 1 FOR 2'S COMPLEMENT
		STI R3, XY		;SAVING RESULT INTO R3
		
		LDI R1, SAVER1		;RESTORE REGISTERS
		LDI R2, SAVER2		;
		LDI R3, SAVER3		;
		LDI R4, SAVER4		;
		RET

;----------------------------DIVIDE-----------------------------------
	;R1 = X, R2 = Y, R3 = COUNTER(END VALUE), R5 = SIGN FLAG

DIV
		STI R1, SAVER1		;SAVING REGISTERS
		STI R2, SAVER2		;
		STI R3, SAVER3		;
		STI R4, SAVER4		;
		STI R5, SAVER5		;
	
		AND R3, R3, #0		;WHOLE PART COUNTER
		AND R5, R5, #0		;SIGN FLAG
		ADD R1, R1, #0		;THIS IS OUR X VALUE
		BRn XNEG2		;IF X IS NEGATIVE THAN CHANGE TO POSITVE
		BR #3			;NOT NEGATIVE

XNEG2		NOT R1, R1		;NEGATING R1(X)
		ADD R1, R1, #1		;ADDING 1 FOR 2'S COMPLEMENT
		NOT R5, R5		;NEGATING R5(SIGN FLAG)
		ADD R2, R2, #0		;CHECKING R2(Y)
		BRn YNEG2		;IF R2(Y) IS NEGATIVE BRANCH 
		BR #3			;IF R2(Y) IS NOT NEGATIVE BRANCH

YNEG2		NOT R2, R2		;NEGATING R2(Y)
		ADD R2, R2, #1		;ADDING 1 FOR 2'S COMPLEMENT
		NOT R5, R5		;NEGATING R5(SIGN FLAG)
		NOT R4, R2		; 
		ADD R4, R4, #1		; 

DIVLOOP		ADD R1, R1, R4		; SUBTRACT Y FROM VALUE OF X		
		BRn #2
		ADD R3, R3, #1		; INCREMENT COUNTER
		BR DIVLOOP		; IF X > Y THAN LOOP
		ADD R5, R5, #0		; CHECKING R5(SIGN FLAG)
		BRn CHANGESIGN2		; IF SIGN FLAG IS NEGATIVE THAN CHANGE SIGN OF R3
		BR #2

CHANGESIGN2	NOT R3, R3		; NEGATING R3
		ADD R3, R3, #1		; ADDING 1 FOR 2'S COMPLEMENT
		STI R3, DIVIDED		; SAVE RESULT OF X/Y			
		
		LDI R1, SAVER1		; RESTORING REGISTERS
		LDI R2, SAVER2		;
		LDI R3, SAVER3		;
		LDI R4, SAVER4		;
		LDI R5, SAVER5		;
		RET

;----------------------------------MODULUS------------------------------
	;R1 = X, R2 = Y, R3 = COUNTER(END VALUE), R5 = SIGN FLAG


MOD
		STI R1, SAVER1		;SAVING REGISTERS
		STI R2, SAVER2		;
		STI R3, SAVER3		;
		STI R4, SAVER4		;
		STI R5, SAVER5		;
		STI R7, SAVER7		;

		AND R5, R5, #0		;CLEARING R5
		ADD R1, R1, #0		;CLEARING R1
		BRn XNEG3		;CHANGE SIGN IF X IS NEGATIVE
		BR #3

XNEG3		NOT R1, R1		;NEGATING R1(X)
		ADD R1, R1, #1		;ADDING 1 FOR 2'S COMPLEMENT
		NOT R5, R5		;CHANGING SIGN FLAG

		ADD R2, R2, #0		;CHECKING R2(Y)
		BRn YNEG3		;IF Y IS NEGATIVE BRANCH
		BR #3

YNEG3		NOT R2, R2		;NEGATING R2(Y)
		ADD R2, R2, #1		;ADDING 1 FOR 2'S COMPLEMENT
		NOT R5, R5		;CHANGING SIGN FLAG
		NOT R3, R2		;	
		ADD R3, R3, #1		;INCREMENT COUNTER
		ADD R4, R1, #0		;MODULUS COUNTER
	
MODLOOP		ADD R1, R1, R3 		; 
		BRn #2			;IF R3 DOES NOT GO INTO R1 EXIT LOOP
		ADD R4, R4, R3		;CONTINUE MODULUS
		
		BR MODLOOP		;LOOP THROUGH AGAIN
		STI R4, MODULUS			
		
		LDI R1, SAVER1		;RESTORE REGISTERS
		LDI R2, SAVER2		;
		LDI R3, SAVER3		;
		LDI R4, SAVER4		;
		LDI R5, SAVER5		;
		LDI R7, SAVER7		;
		RET


;-------------------THIS FUNCTION PUSHES AND POPS FOR OUTPUT-------------------------------
	
OUTPUT
		STI R1, SAVER1			;SAVE REGISTERS
		STI R2, SAVER2			;
		STI R3, SAVER3			;
		STI R4, SAVER4			;
		STI R5, SAVER5			;
		STI R7, SAVER7			;
		
		ADD R5, R5, #10		;COUNTER FOR 10 RANDOM NUMBERS(I KNOW ITS SUPPOSED TO BE 20)
		LD R1, X		;R1 LOADED WITH X VALUE
		LD R2, DIVMOD		;R2 LOADED WITH 10
		ADD R3, R3, #1		;SIGN FLAG
		ADD R1, R1, #0
		BRn REMNEG		;IF X<0 BRANCH AND CHANGE SIGN FLAG
		BRz REMZERO		;IF X=0 BRANCH AND PUSH ZERO
		
PUSHLOOP	ADD R2, R2, #0
		ADD R1, R1, #0
		JSR MOD			;GET LAST DIGIT OF THE X VALUE 
		LDI R4, MODULUS		;LAST DIGIT OF X VALUE
		JSR PUSH		;PUSHED LAST DIGIT OF X VALUE
		AND R2, R2, #0		;CLEAR R2
		LD R2, DIVMOD		;LOAD R2 WITH 10
		ADD R1, R1, #0
		JSR DIV			;DIVIDE REMAINING VALUE OF X BY 10 TO GET DIGIT
		BRn NEGDIV		;IF REMAINING X IS NEGATIVE THAN JUMP TO NEGASCII
		JSR ITOA
		LD R0, DIGIT
		JSR PUSH		;EX.) X=735 NOW EQUALS 5 AFTER MOD AND 73 AFTER DIV.
		ADD R5, R5, #-1		;DECREMENTS PUSH COUNTER
		BRz POPLOOP
		
REMNEG		NOT R3, R3
		ADD R3, R3, #1
		BR PUSHLOOP
		
		

REMZERO		JSR ITOA
		JSR PUSH
		ADD R5, R5, #-1
		BRz POPLOOP
		RET

NEGDIV		JSR NEGASCII
		JSR PUSH
		RET	

POPLOOP		JSR ISEMPTY
		BRp  ENDPOP
		JSR POP
		STI R0, XOUTPUT
		BR POPLOOP
ENDPOP		.STRINGZ "END OF RANDOM NUMBERS"
		RET


		LDI R1, SAVER1		;RESTORE REGISTERS
		LDI R2, SAVER2		;
		LDI R3, SAVER3		;
		LDI R4, SAVER4		;
		LDI R5, SAVER5		;
		LDI R7, SAVER7		;
		RET
	
BASE		.FILL x4000
DIVMOD		.FILL #10
DIGIT		.FILL x0000

;--------------------------INTEGER TO ASCII----------------------------------------
ITOA        	ST  R3, SAVER3
      		AND R0, R0, #0    	; CLEAR R0
        	ADD R0, R6, R0    	; LOAD INTEGER INTO R0
        	AND R3, R3, #0    	; CLEAR R3 
        	LD  R3, ASCII     	; LOAD ASCII INTO R3
	       	ADD R0, R0, R3    	; MAKE ASCII CHARACTER FOR OUTPUT
        	LD  R3, SAVER3
        	RET

ASCII		.FILL x30

;-----------------NEGATIVE ASCII----------------------------------------------------
NEGASCII	NOT R3, R3		;NEGATE R3 TO OBTAIN NEGATIVE
		ADD R3, R3, #1		;ADD 1 FOR 2'S COMPLEMENT
		LD R1, MINUS		;LOAD NEGATIVE SIGN IN ASCII AND STORE IN R1
		OUT
		LD R0, OFFSET		;LOAD ZERO IN ASCII INTO R0
		ADD R0, R1, R3		;ADD NEGATIVE AND DIGIT AND STORE WITH ASCII	
	        RET

MINUS		.FILL x2D		;NEGATIVE SIGN IN ASCII
OFFSET		.FILL x30		;ZERO IN ASCII


;--------------------------------INPUT BY PUSH---------------------------------------


PUSH		LD R6, BASE		;M[x4000]
		ADD R6, R6, #-1		;M[x3FFF]-->BASE-1(MOVES UP)
		STR R0, R6, #0		;THE CONTENTS OF R0 ARE STORED INTO M[R6]
		RET			;RETURN FROM SUBROUTINE(ORIGINALLY STORED IN R7)

;--------------------------------OUTPUT BY POP---------------------------------------

POP		LDR R0, R6, #0		;LOAD R0 WITH TOP OF STACK
		ADD R6, R6, #1		;MOVE TOP OF STACK DOWN
		RET			;RETURN FROM SUBROUTINE(ORIGINALLY STORED IN R7)

;---------------------------------UNDERFLOW-------------------------------------------

ISEMPTY		LD R0, EMPTY		;R0 = M[-x4000]
		ADD R0, R6, R0		;R0 = R6 + R0 TO COMPARE IF EMPTY
		BRz IS			;BRANCH IF STACK IS EMPTY
		ADD R0, R0, #0		;IF NOT EMPTY RETURN 0 TO BRANCH APPROPRIATELY IN LATER SUBROUTINE
		RET

IS		AND R0, R0, #0		;CLEARING R0
		ADD R0, R0, #1		;ADDING 1 TO R0 TO BRANCH OUT IN LATER SUBROUTINE
		RET

EMPTY		.FILL xC000		;M[-4000] TO COMPARE TO BASE M[4000]
	
;USED TO SAVE AND RESTORE REGISTERS
SAVER1 .FILL x3500
SAVER2 .FILL x3501
SAVER3 .FILL x3502
SAVER4 .FILL x3503
SAVER5 .FILL x3504
SAVER7 .FILL x3505

.END

